<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="src/index.css">
  <link rel="stylesheet" href="src/datagrid.css">
  <link rel="stylesheet" href="src/errorcontainer.css">
  <title>SVAppLog</title>
</head>
<body>
  <div class="header">
    <div class="logo">
      <img src="src/logo.png" alt="Logo">
    </div>
    <div id="errorMessages" class="error-container" style="display: none;">
      <span class="close-btn" onclick="closeError()">x</span>
      <p class="error-text"></p>
    </div>
  </div>
  <div class="main">
    <item>
      <button id="fetchButton" class="fetchButton">Fetch JSON Data</button>
      <div class="right-group">
        <label for="type">Filter by type:</label>
        <select name="type" id="type">
          <option value="">All</option>
          <option value="login">Login</option>
          <option value="logout">Logout</option>
          <option value="register">Register</option>
        </select>
      </div>
    </item>
    <div id="results">
      <table id="dataGrid" class="dataGrid" border="1">
        <thead>
          <tr>
            <th data-column="id">User_ID<span class="sort-arrow"></span></th>
            <th data-column="user">User<span class="sort-arrow"></span></th>
            <th data-column="type">Action<span class="sort-arrow"></span></th>
            <th data-column="timestamp">Time Stamp<span class="sort-arrow"></span></th>
            <th data-column="path">Path<span class="sort-arrow"></span></th>
          </tr>
        </thead>
        <tbody>
        </tbody>
      </table>
    </div>
  </div>
  <div class="footer">
    <p>For contact: <a href="mailto:vaskokole@abv.bg">vaskokole@abv.bg</a> / <a href="mailto:p0lyb3ar@proton.me">p0lyb3ar@proton.me</a></p>
  </div>
  <script>
    class TrieNode {
      constructor() {
        this.children = {};
        this.isEndOfWord = false;
      }
    }

    class Trie {
      constructor() {
        this.root = new TrieNode();
      }

      insert(word) {
        let node = this.root;
        for (let char of word) {
          if (!node.children[char]) {
            node.children[char] = new TrieNode();
          }
          node = node.children[char];
        }
        node.isEndOfWord = true;
      }

      search(word) {
        let node = this.root;
        for (let char of word) {
          if (!node.children[char]) {
            return false;
          }
          node = node.children[char];
        }
        return node.isEndOfWord;
      }

      startsWith(prefix) {
        let node = this.root;
        for (let char of prefix) {
          if (!node.children[char]) {
            return false;
          }
          node = node.children[char];
        }
        return true;
      }

      collectWords(node = this.root, prefix = '', result = []) {
        if (node.isEndOfWord) {
          result.push(prefix);
        }
        for (let char in node.children) {
          this.collectWords(node.children[char], prefix + char, result);
        }
        return result;
      }
    }

    function mergeSort(arr, key) {
      if (arr.length <= 1) return arr;

      const middle = Math.floor(arr.length / 2);
      const left = arr.slice(0, middle);
      const right = arr.slice(middle);

      return merge(mergeSort(left, key), mergeSort(right, key), key);
    }

    function merge(left, right, key) {
      let result = [];
      let leftIndex = 0;
      let rightIndex = 0;

      while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex][key] < right[rightIndex][key]) {
          result.push(left[leftIndex]);
          leftIndex++;
        } else {
          result.push(right[rightIndex]);
          rightIndex++;
        }
      }

      return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
    }

    let currentSort = {
      key: null,
      direction: 'asc'
    };

    document.getElementById('fetchButton').addEventListener('click', fetchData);
    document.getElementById('type').addEventListener('change', fetchData);

    function fetchData() {
      const typeValue = document.getElementById('type').value;
      const url = `http://localhost:8000/read?logs=all&dict=1&sort=${typeValue}`;

      console.log('Fetching data from URL:', url); // Debugging

      fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok ' + response.statusText);
          }
          return response.json();
        })
        .then(data => {
          console.log('Fetched Data:', data); // Debugging
          updateTable(data);
        })
        .catch(error => {
          showError(error.message);
        });
    }

    function updateTable(data) {
      const tableBody = document.getElementById('dataGrid').getElementsByTagName('tbody')[0];
      tableBody.innerHTML = ''; // Clear previous results

      console.log('Updating table with data:', data); // Debugging

      // Assuming data is an array of objects
      data.forEach(item => {
        const newRow = tableBody.insertRow();
        const userIdCell = newRow.insertCell(0);
        const userCell = newRow.insertCell(1);
        const actionCell = newRow.insertCell(2);
        const timestampCell = newRow.insertCell(3);
        const pathCell = newRow.insertCell(4);

        userIdCell.textContent = item.id || 'None';
        userCell.textContent = item.data?.user || 'None';
        actionCell.textContent = item.type || 'None';
        timestampCell.textContent = new Date(item.timestamp).toLocaleString() || 'None';
        pathCell.textContent = item.path || 'None';
      });
    }

    function showError(message) {
      const errorContainer = document.getElementById('errorMessages');
      const errorText = errorContainer.querySelector('.error-text');
      errorText.textContent = 'Error: ' + message;
      errorContainer.style.display = 'block'; // Show the error container
    }

    function closeError() {
      const errorContainer = document.getElementById('errorMessages');
      errorContainer.style.display = 'none'; // Hide the error container
    }

    function handleHeaderClick(event) {
      const th = event.target;
      const sortKey = th.getAttribute('data-column');

      if (!sortKey) return;

      if (currentSort.key === sortKey) {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
      } else {
        currentSort.key = sortKey;
        currentSort.direction = 'asc';
      }

      sortTable(sortKey, currentSort.direction);
    }

    function sortTable(key, direction) {
      const tableBody = document.getElementById('dataGrid').getElementsByTagName('tbody')[0];
      const rowsArray = Array.from(tableBody.rows);

      let dataArray = rowsArray.map(row => {
        return {
          row: row,
          id: parseInt(row.cells[0].textContent, 10),
          user: row.cells[1].textContent,
          action: row.cells[2].textContent,
          timestamp: new Date(row.cells[3].textContent).getTime(),
          path: row.cells[4].textContent
        };
      });

      if (key === 'timestamp') {
        dataArray = mergeSort(dataArray, key);
      } else if (key === 'id') {
        dataArray = mergeSort(dataArray, key);
      } else {
        dataArray.sort((a, b) => {
          if (direction === 'asc') {
            return a[key] > b[key] ? 1 : -1;
          } else {
            return a[key] < b[key] ? 1 : -1;
          }
        });
      }

      // Append sorted rows to the table body
      dataArray.forEach(item => tableBody.appendChild(item.row));
    }

    document.querySelectorAll('#dataGrid th').forEach(th => {
      th.addEventListener('click', handleHeaderClick);
    });
  </script>
</body>
</html>
